<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>متلب درس سیگنال سیستم</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="styles.css" rel="stylesheet"/>    
  </head>
  <body dir="rtl">
    <main id="main-doc">
      <nav id="navbar">
          <a class="nav-link" href="#first">فصل 1</a>
          <a class="nav-link" href="#second">فصل 2</a>
          <a class="nav-link" href="#third">فصل 3</a>
          <a class="nav-link" href="#fourth">فصل 4</a>
          <a class="nav-link" href="#prj">پروژه</a>
      </nav>
      <h1>متلب درس سیگنال سیستم</h1>
      <section class="main-section" id="first">
        <header>فصل اول: نمودار‌ها در متلب</header>
        <h2>بخش اول: رسم نمودار‌های سیگنال به صورت پیوسته</h2>
        <p>برای رسم توابع پیوسته از تابع plot استفاده می‌کنیم. دو ورودی اول این تابع به ترتیب متغییر محور افقی و عمودی هستند و بقیه‌ی ورودی‌ها برای تعیین شکل نمودار است.  برای رسم چند نمودار در یک صفحه و در کنار هم، از subplot استفاده می‌کنیم. که ورودی اول و دوم آن تعیین‌کننده‌ی ستون و ردیف و ورودی سوم تعیین کننده‌ی محل نمودار است.</p>
        <code>%% 1-1) Ploting continuous time signals:<br/>
          clear; clc; figure(1)<br/>
          t = linspace(-3*pi,3*pi,1000);<br/>
          <br/>
          subplot(2,2,1)<br/>
          plot(t,sin(t),"color", [0, 0, 0.7] ,"LineWidth", 3);<br/>
          hold on;<br/>
          plot(t,cos(t),"color", [0.5, 0.5, 1] ,"LineWidth", 3);<br/>
          grid on;<br/>
          xlabel("-----  t  -----");<br/>
          ylabel("----- Sin(t) & Cos(t) -----")<br/>
          legend("Sin(t)", "Cos(t)");<br/>
          <br/>
          subplot(2,2,2)<br/>
          plot(t,sinc(t),"color", [0.3, 0.5, 0.5] ,"LineWidth", 3);<br/>
          xlabel("-----  t  -----");<br/>
          ylabel("----- Sinc(t) -----");</code>
        <h2>بخش دوم: رسم نمودار‌های سیگنال به صورت گسسته</h2>
        <p>برای رسم توابع گسسته از تابع stem  استفاده می‌کنیم. عملکرد این تابع از نظر ورودی‌ها دقیقا شبیه plot است و تنها تفاوت نحوه‌ی رسم نمودارها است. اینجا هم می‌شود از subplot استفاده کرد.</p>
        <code>%% 1-2) Plotting discrete time signals:<br/>
          n = -3*pi : pi/8 : 3*pi;<br/>
          <br/>
          subplot(2,2,3)<br/>
          stem(n,sin(n),"color", [0, 0, 0.7] ,"LineWidth", 2);<br/>
          hold on;<br/>
          stem(n,cos(n),"color", [0.5, 0.5, 1] ,"LineWidth", 2);<br/>
          xlabel("-----  n  -----");<br/>
          ylabel("----- Sin(n) & Cos(n) -----")<br/>
          legend("Sin(n)", "Cos(n)");<br/>
          <br/>
          subplot(2,2,4)<br/>
          stem(n,sinc(n),"color", [0.3, 0.5, 0.5] ,"LineWidth", 2);<br/>
          xlabel("-----  n  -----");<br/>
          ylabel("----- Sinc(n) -----");</code>
        <h2>بخش سوم: مقدار میانگین سیگنال (گسسته)</h2>
        <p>تابع mean در متلب، به عنوان ورودی یک لیست می‌گیرد و میانگین آن‌ها را به عنوان خروجی می‌دهد. به همین دلیل از همین تابع می‌توان برای محاسبه‌ی مقدار میانگین سیگنال‌های گسسته استفاده کرد.</p>
        <code>%% 1-3) Calculating the signal's average value (discrete)<br/>
          n = -3*pi : pi/8 : 3*pi;<br/>
          f = sinc(n);<br/>
          f_avg = mean(f);<br/>
          disp("1-3)");<br/>
          disp("Average of the discrete sinc(n) signal from -3pi to 3pi is ((  "+f_avg+"  ))");<br/>
          disp("-------------------");</code>
        <h2>بخش چهارم: انرژی و توان سیگنال (گسسته)</h2>
        <p>تابع sum در متلب، به عنوان ورودی یک لیست می‌گیرد و جمع آن‌ها را به عنوان خروجی می‌دهد. به همین دلیل از همین تابع می‌توان برای محاسبه‌ی انرژی‌ و توان سیگنال‌های گسسته استفاده کرد. چون انرژی این سیگنال‌ها در یک بازه‌ی مشخص برابر با جمع توان دوم سیگنال است.</p>
        <code>%% 1-4) Calculating the signal's energy and power (discrete)<br/>
          n = -3*pi : pi/8 : 3*pi;<br/>
          f = sinc(n);<br/>
          f_enegry = sum(f.*f);<br/>
          disp("1-4)");<br/>
          disp("The discrete sinc(n) signal's energy from -3pi to 3pi is ((  "+f_enegry+"  ))");<br/>
          disp("-------------------");<br/>
          f_power = f_enegry / length(f);<br/>
          disp("The discrete sinc(n) signal's power from -3pi to 3pi is ((  "+f_power+"  ))");<br/>
          disp("-------------------");</code>
          <h2>بخش پنجم: تعریف و رسم سیگنال چند ضابطه ای در متلب</h2>
          <p>در متلب نتیجه‌ی استفاده از عملگر‌های مقایسه‌ای به صورت true یا false یا به عبارتی عدد صفر یا یک است. از این ویژگی می‌توان برای تعریف توابع چند ضابطه‌ای در یک خط استفاده کرد.</p>
          <code>%% 1-5) Defining and plotting a piecewise function<br/>
            figure(2)<br/>
            t = linspace(-1,2,1000);<br/>
            x = (t <= 1).*(2*t) + (t > 1)*(2);<br/>
            %subplot(3,2,5)<br/>
            plot(t,x,"color", [0.5, 0.7, 0.5] ,"LineWidth", 7);<br/>
            grid on;</code>
            <a href="https://github.com/PariyaPl/Signal-Matlab-Files/blob/main/SignalSystemFasl1Matlab.m">مشاهده‌ کل کد‌های فصل اول</a>
      </section>
      <div class="divi"></div>

      <section class="main-section" id="second">
        <header>فصل دوم: توابع متلب برای سیستم‌ها</header>
        <h2>بخش اول: تعریف سیستم خطی به صورت تابع تبدیل</h2>
        <p>سیستم خطی در متلب با استفاده از تابع tf تعریف می‌شود. ورودی اول و دوم این تابع به ترتیب ضرایب صورت و مخرج تابع تبدیل سیستم هستند.</p>
        <code>%% 2-1) Defining a system as transfer function<br/>
          clc; clear;<br/>
          <br/>
          numerator = [1,2];      % s + 2<br/>
          denominator = [3,4,5];  % 3s^2 + 4s + 5<br/>
          disp("2-1)");<br/>
          system1 = tf(numerator,denominator)<br/>
          disp("----------------------------------");</code>
        <h2>بخش دوم: ترکیب کردن سیستم‌ها در متلب</h2>
        <p>توابع series، parallel، و feedback در متلب برای ترکیب سیستم‌هایی که به کمک tf تعریف می‌شوند.</p>
        <code>%% 2-2) Combining systems<br/>
          disp("2-2)");<br/>
          system2 = tf([2,3],[1,2,3])<br/>
          <br/>
          systemsSeries = series(system1,system2)<br/>
          <br/>
          systemsParallel = parallel(system1,system2)<br/>
          <br/>
          systemsFeedback = feedback(system1,system2)<br/>
          <br/>
          disp("----------------------------------");</code>
        <h2>بخش سوم: رسم پاسخ ضربه و پله‌ی سیستم</h2>
        <p>تابع impulse و Step  در متلب، یک سیستم به عنوان ورودی می‌گیرند. اگر این توابع فقط فراخوانی شوند، به ترتیب پاسخ ضربه و پاسخ پله‌ی سیستم را رسم می‌کنند. اما می‌شود حاصل فراخوانی این توابع را مساوی لیستی شامل دو پارامتر قرار داد. در این صورت این لیست، سیگنال مربوطه خواهد بود، به این صورت که پارامتر اول لیست، مقدار نمودار عمودی و پارامتر دوم، مقدار نمودار افقی یا در واقع زمان است. با داشتن این دو پارامتر می‌توانیم سیگنال‌ها را بررسی کنیم و یا مثل کد متلبی که در ادامه آورده شده آن‌ها را با رنگ و شکل دلخواه رسم کنیم.</p>
        <code>%% 2-3) System's impulse response and step response<br/>
          figure(1);<br/>
          <br/>
          [h,t] = impulse(system1);   % Impulse response<br/>
          plot(t,h,"color", [0, 0, 0.7] ,"LineWidth", 3);<br/>
          <br/>
          hold on<br/>
          <br/>
          [s,t] = step(system1);      % Step response<br/>
          plot(t,s,"color", [0.9, 0.5, 0.5] ,"LineWidth", 3);<br/>
          <br/>
          grid on<br/>
          title("Impulse and Step response")<br/>
          legend("Impulse response", "Step response")<br/>
          <br/>
          %% 2-3+) Other option: the folowing codes will plot responses instantly<br/>
          % (only this way you can't change your plot style or color<br/>
          figure(2); impulse(system1); hold on;<br/>
          figure(2); step(system1);</code>
        <h2>بخش چهارم: رسم پاسخ سیستم به ورودی‌ دلخواه</h2>
        <p>تابع lsim برای رسم پاسخ سیستم به ورودی دلخواه استفاده می‌شود. این تابع سه ورودی دارد. ورودی اول، سیستم است که با تابع tf متلب تعریف شده و ورودی دوم و سوم سیگنال ورودی هستند. به این ترتیب که دومین ورودی محور افقی و سومین ورودی محور زمان است. خروجی سیستم برابر با لیستی شامل محور عمودی و محور زمان برای سیگنال خروجی خواهد بود. مشابه توابع بخش قبل، اگر نتیجه‌ی تابع برابر لیست قرار داده نشود و تابع فقط فراخوانی شود، ورودی و خروجی سیستم بر روی یک نمودار با هم رسم می‌شوند.</p>
        <code>%% 2-4) Systems response to any desired input<br/>
          figure(3);<br/>
          t = 0:0.01:3;<br/>
          x = sin(10*t).*exp(-10*t);<br/>
          [y,t] = lsim(system1,x,t);   % u,t define the input signal<br/>
          <br/>
          plot(t,x,"color", [0, 0.6, 0] ,"LineWidth", 3);   % plot input<br/>
          hold on<br/>
          plot(t,y,"color", [0.9, 0, 0.5] ,"LineWidth", 3);   % plot output<br/>
          <br/>
          grid on<br/>
          title("Impulse and Step response")<br/>
          legend("x = e^{-10t}Sin(10t)", "y(system output for x)")<br/>
          <br/>
          %% 2-4) Other option: like before we can plot the output with the folowing code:<br/>
          figure(4); lsim(system1,x,t);<br/>
          </code>
        <a href="https://github.com/PariyaPl/Signal-Matlab-Files/blob/main/SignalSystemFasl2Matlab.m">مشاهده‌ کل کد‌های فصل دوم</a>
      </section>
      <div class="divi"></div>

      <section class="main-section" id="third">
        <header>فصل سوم: شرط‌ها، لوپ‌ها و تعریف توابع در متلب</header>
        <h2>بخش اول: دستورات شرطی if و switch در متلب</h2>
        <p>در ادامه برای معرفی سینتکس if و switch از هر کدام یک مثال آورده شده. در مثال مربوط به if، اگر شرط اول برقرار نباشد، شرط دوم یعنی elseif بررسی می‌شود و اگر این شرط هم برقرار نباشد، نهایتا دستورات بخش else انجام می‌شود. در مثال مربوط به switch، متغییری که مورد بررسی قرار گرفته، زاویه‌ی عدد مختلط z است که با استفاده از تابع angle در متلب به دست آمده. در صورت برابر بودن این زاویه با هر یک از اعدادی که مقابل caseها آورده شده اند، دستورات مربوطه اجرا می‌شود. و اگر با هیچ کدام برابر نبود، دستورات بخش otherwise اجرا می‌شود. </p>
        <code>%% 3-1) 1- if<br/>
          clc; clear;<br/>
          <br/>
          z = input("Enter a complex number:   ");<br/>
          if abs(z)==1 <br/>
              disp("Your number is on the unit circle");<br/>
          elseif abs(z) < 1<br/>
              disp("Your number is in the unit circle");<br/>
          else<br/>
              disp("Your number is out of the unit circle");<br/>
          end<br/>
          <br/>
          %% 3-1) 2- switch<br/>
          z = input("Enter a complex number:   ");<br/>
          switch angle(z) <br/>
              case 0<br/>
                  disp("Your number is on the right side of the Real axis");<br/>
              case pi<br/>
                  disp("Your number is on the left side of the Real axis");<br/>
              case pi/2<br/>
                  disp("Your number is on the Upper side of the Imaginary axis");<br/>
              case 3*pi/2<br/>
                  disp("Your number is on the Upper side of the Imaginary axis");<br/>
              otherwise<br/>
                  disp("Your number is not on the Real or Imaginary axis");<br/>
          end<br/>
          </code>
        <h2>بخش دوم: حلقه‌های for و while در متلب</h2>
        <p>سینتکس لوپ for و while در ادامه با یک مثال آورده شده. هر دو مقادیر ضرایب سری فوریه‌ی یک سیگنال گسسته با دوره تناوب ده را از کاربر می‌گیرند و با استفاده از رابطه‌ی پارسوال انرژی سیگنال را حساب می‌کنند. در این مثال دستور for، مقدار n را برابر با یک لیست از اعداد صحیح از یک تا ده قرار داده. در متلب این لیست می‌تواند هر لیستی از اعداد یا مقادیر دیگر باشد. برای مثال این لیست می‌تواند شامل تعداد متغییر از نوع string باشد و حلقه در هر دور به ترتیب n را برابر با یکی از آن‌ها در نظر می‌گیرد.</p>
        <code>%% 3-2) 1- for<br/>
          disp("Enter the fourier series coefficients of a signal with N=10");<br/>
          Power = 0;<br/>
          for n = 1:10<br/>
              disp("---------------------------------------");<br/>
              c = input("Enter coefficient no." + n + ":   ");<br/>
              Power = Power + c^2;<br/>
          end<br/>
          disp("The signal's power is:  "+Power);<br/>
          <br/>
          %% 3-2) 2- while<br/>
          disp("Enter the fourier series coefficients of a signal with N=10");<br/>
          Power = 0;<br/>
          n = 1;<br/>
          c = 0;<br/>
          while n < 11<br/>
              disp("---------------------------------------");<br/>
              c = input("Enter coefficient no." + n + ":   ");<br/>
              Power = Power + c^2;<br/>
              n = n+1;<br/>
          end<br/>
          disp("The signal's power is:  "+Power);<br/>
          </code>
        <h2>بخش سوم: تعریف توابع در متلب</h2>
        <p>برای تعریف تابع در متلب، باید اول از قسمت new، "Function" را انتخاب کنیم. این کار یک فایل جدید برای ما می‌سازد که فایل تابع است. اسم تابع، بعد از علامت مساوی نوشته می‌شود. در مثال زیر اسم این تابع PowerWithParseval است. برای اینکه متلب بتواند تابع را خارج از این فایل پیدا کند. اسم فایل تابع هم باید به صورت PowerWithParseval.m باشد. <br/><br/>
          عملکرد تابعی که در مثال زیر تعریف شده است، به این صورت است که مقادیر ضرایب سری فوریه گسسته را در یک لیست به عنوان ورودی دریافت می‌کند و توان سیگنال را با استفاده از تابع sum روی توان دوی ضرایب به دست می‌آورد. (رابطه‌ی پارسوال)
          </p>
        <code>function Power = PowerWithParseval(FourierCoefficients)<br/>
          Power = sum(FourierCoefficients.^2);<br/>
          end</code>
      </section>
      <div class="divi"></div>

      <section class="main-section" id="fourth">
        <header>فصل چهارم: توابع متلب برای محاسبات کاربردی</header>
        <h2>بخش اول: تبدیل لاپلاس در متلب</h2>
        <p>برای محاسبه‌ی تبدیل لاپلاس یک تابع در متلب، ابتدا باید t را به عنوان یک متغییر سمبلیک تعریف کنیم. این کار به کمک syms در متلب انجام می‌شود. بعد باید تابع مورد نظر را با استفاده از متغییر t تعریف کنیم و آن را به عنوان ورودی به تابع laplace متلب بدهیم. خروجی برابر تبدیل لاپلاس آن خواهد شد.</p>
        <code>%% 4-1) Laplace transform<br/>
          clear; clc;<br/>
          syms t <br/>
          f = sin(t);<br/>
          F = laplace(f);<br/>
          disp("4-1)")<br/>
          disp("laplace transform of Sin(t) is: ")<br/>
          disp(F)<br/>
          </code>
        <h2>بخش دوم: تبدیل معکوس لاپلاس در متلب</h2>
        <p>محاسبه‌ی معکوس تبدیل لاپلاس با استفاده از متلب، مشابه لاپلاس است. این بار باید s را به کمک syms تعریف کنیم و تابع مورد نظر را با استفاده از آن تعریف کنیم و آن را به عنوان ورودی به تابع ilaplace بدهیم. خروجی معکوس تبدیل لاپلاس خواهد بود.</p>
        <code>%% 4-2) Inverse laplace transform<br/>
          syms s<br/>
          F = 1/(s^2 + 1);<br/>
          f = ilaplace(F);<br/>
          disp("4-2)")<br/>
          disp("Inverse laplace transform of 1/(s^2 + 1) is: ")<br/>
          disp(f)<br/>
          </code>
        <h2>بخش سوم: محاسبه حد به کمک متلب</h2>
        <p>تابع limit در متلب برای محاسبه‌ی حد است. در مثال زیر، اولین ورودی این تابع، عبارتی است که از آن حد می‌گیریم. حد این عبارت در حالتی که h (ورودی دوم) به سمت صفر (ورودی سوم) میل می‌کند محاسبه می‌شود.</p>
        <code>%% 4-3) limit in matlab<br/>
          syms h n x;<br/>
          LimX = limit((sin(x+h)-sin(x))/h, h, 0);<br/>
          disp("4-3)")<br/>
          disp("The answer to lim((sin(x+h)-sin(x))/h) when h -> 0 is: ")<br/>
          disp(LimX);<br/>
          </code>
        <h2>بخش چهارم: مشتق و انتگرال در متلب</h2>
        <p>برای گرفتن مشتق از یک تابع نسبت به یک متغییر، اول باید متغییر‌های تابع را به کمک syms تعریف کنیم. سپس تابع را به کمک متغییرهایش تعریف کنیم و بعد از تابع مشتق متلب یعنی diff استفاده کنیم. ورودی اول آن، تابعی است که می‌خواهیم مشتق آن را محاسبه کنیم و ورودی دوم متغییری است که می‌خواهیم نسبت به آن مشتق بگیریم. اگر علاوه بر این به diff یک ورودی دیگر هم به صورت اعداد طبیعی بدهیم، diff این عدد را به عنوان درجه‌ی مشتق در نظر می‌گیرد. برای مثال اگر عدد دو را به عنوان ورودی سوم بدهیم، مشتق مرتبه‌ دوم را به عنوان خروجی می‌دهد.
          <br/> <br/>
          در ادامه‌ی کد زیر، نحوه‌ی استفاده از تابع integral هم با یک مثال آورده شده. برای استفاده از آن باید تابع x را با استفاده از علامت @ تعریف کنیم. این علامت مشخص می‌کند که تابع x نسبت به چه متغییری انتگرال گیری شود.در مثال زیر این متغییر t است. ورودی اول integral، تابع x است و ورودی دوم و سوم، حد پایین و بالای انتگرال‌گیری هستند.
          </p>
        <code>%% 4-4) 1- Differentiation <br/>
          disp("4-4)")<br/>
          <br/>
          syms t a<br/>
          x = sin(a*t);<br/>
          <br/>
          dx_dt = diff(x,t);  <br/>
          disp("For x=sin(a*t), dx/dt is: ")<br/>
          disp(dx_dt);<br/>
          <br/>
          d2x_dt2 = diff(x,t,2);<br/>
          disp("For x=sin(a*t), d^2x/dt^2 is: ")<br/>
          disp(d2x_dt2);<br/>
          <br/>
          %% 4-4) 2- Integral<br/>
          <br/>
          % Defining the signal that we want to calculate its integral:<br/>
          x = @(t) exp(-t).*sin(t);    % don't forget the dots<br/>
          disp("The integral of exp(-t).*sin(t) from 0 to pi is: ")<br/>
          Int_x = integral(x,0,pi);<br/>
          <br/>
          disp(Int_x);<br/>
          </code>
        <h2>بخش پنجم: رسم تبدیل فوریه توابع به کمک متلب</h2>
        <p>الگوی زیر برای به دست آوردن تبدیل فوریه سیگنال با کمک تابع fft و نمایش دادن آن استفاده می‌شود که در کلاس توضیح داده شد.</p>
        <code>%% 4-5) Ploting a function's fourier transform Magnitude<br/>
          Ts = 1/50;<br/>
          t = 0:Ts:10-Ts;<br/>
          x = sin(10*2*pi*t) + 2*sin(5*2*pi*t); <br/>
          <br/>
          X = fft(x);  % Fourier Transform<br/>
          X_shift = fftshift(X);<br/>
          <br/>
          Fs = 1/Ts;   % Sampling frequency<br/>
          n = length(x);<br/>
          f = (-n/2:n/2-1)*(Fs/n); % Frequency axis<br/>
          <br/>
          figure(1);<br/>
          plot(f, abs(X_shift) ,"color", [0, 0, 0.7] ,"LineWidth", 2);<br/>
          xlabel('Frequency (Hz)');<br/>
          ylabel('Magnitude');<br/>
          title('Magnitude of the Fourier Transform');<br/>
          </code>
      </section>
      <div class="divi"></div>

      <section class="main-section" id="prj">
        <header>پروژه</header>
        <p></p>
        <code></code>
      </section>
    </main>

  </body>
</html>
